# Serverless Image Processing Pipeline

This is a full-stack serverless application that converts `.jpg` or `.jpeg` image files to `.png` format using AWS Lambda, S3, and other services. The front end is built with React, the backend is composed of Lambda functions written in Node.js, and the infrastructure is deployed using Terraform with CI/CD powered by GitHub Actions. The application architecture is event-driven, with hosting provided via S3 and CloudFront.

---

Explore the live demo and upload your own .jpg/.jpeg: [Image Converter](https://dlp3grxh7samf.cloudfront.net)

## How to Use
1. **Drag and drop** one or more `.jpg` or `.jpeg` files into the upload area.
2. **Click "Upload Files"** to begin the upload process.
3. Wait a few seconds while the images are automatically converted to `.png` format.
4. Once conversion is complete, **click the provided link** for each image to open it in a new browser tab.
5. **Right-click** on the image in the new tab and select **"Save As..."** to download it to your preferred location.


---

## Overview

- Users upload images via a drag-and-drop React interface.
- Uploads are sent to an S3 bucket using pre-signed URLs generated by a Lambda function.
- Another Lambda function is triggered by S3 to convert uploaded images to `.png` using the Sharp library.
- Converted files are stored in a separate S3 bucket and made accessible via public URLs.
- The frontend is hosted via S3 static site hosting and served globally through a CloudFront distribution.
- Infrastructure is defined in Terraform and deployed automatically through GitHub Actions.

## Architecture

### AWS Services Used

- **S3**: for storing input `.jpg` files and output `.png` files
- **Lambda**: one function for generating pre-signed S3 upload URLs and one for converting images
- **IAM**: manages permissions for Lambdas and CI deployment
- **CloudFront**: serves the React application hosted in S3
- **CloudWatch**: logs events and Lambda executions (mainly used for debugging an issue with the Sharp package not working correctly)
- **DynamoDB**: used as a Terraform state lock for safe concurrent deployments

### System Flow

1. User drags and drops image(s) into the React app.
2. The app fetches a pre-signed URL from a Lambda function deployed behind an API Gateway.
3. The image is uploaded to the input S3 bucket via PUT request.
4. S3 triggers a separate Lambda function automatically to convert the image to `.png`. This event-driven flow eliminates the need for manual polling or scheduling.
5. The converted `.png` image is uploaded to the output S3 bucket with `public-read` access.
6. The front end displays a URL that links directly to the converted `.png` file, allowing users to preview and download the result.

### Event Triggers

1. **User-Initiated Upload**  
   When a user drops a `.jpg` or `.jpeg` file into the React interface and clicks “Upload,” the frontend calls a Lambda function that returns a pre-signed S3 URL. The image is then uploaded directly to an S3 input bucket via a PUT request.

2. **S3-Initiated Processing**  
   Once the file is uploaded, the input S3 bucket automatically triggers a second Lambda function through an S3 event notification. This function processes the image using the Sharp library and stores the converted `.png` file in a separate output S3 bucket.

These two events enable a fully automated, serverless pipeline without the need for polling or manual orchestration.


## CI/CD

- On push to the GitHub repository, GitHub Actions deploys the backend via Terraform.
- Terraform uses a remote S3 backend for state management, with state locking via DynamoDB.
- AWS credentials are injected via GitHub Secrets.
- The frontend is deployed to an S3 bucket and distributed via CloudFront.

## Notes

- The entire infrastructure was deployed using Terraform.
- During development, several AWS permissions and service configurations were manually added in the AWS Console to get the system functioning correctly. This included permissions for IAM, S3 access controls, and DynamoDB roles.
- Pre-signed upload URLs expire after 60 seconds to enforce secure, time-limited uploads.
- Converted image files are served via public S3 links using `public-read` ACLs.
- Lambda logs are available in CloudWatch for both the upload and image-processing functions.
